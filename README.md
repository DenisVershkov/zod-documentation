Общая информация

Zod - это библиотека для написания схем и парсинга данных.

Хотя основной областью применения библиотеки является валидация форм, это не валидатор в чистом виде, в первую очередь это парсер схем.

Основной вопрос который хотелось бы обсудить в рамках данного раздела: что такое парсинг схем и чем он отличается от валидации. Это поможет сформировать понимание основ, на которых построена библиотека Zod, а также идей, заложенных в нее.

Валидация

Цель валидации:  проверить данные на соответствие определенным критериям и выбросить ошибку, если проверка не завершилась успехом.

Рассмотрим пример функции-валидатора:

function validateNonEmpty(data: unknown) {
    if (!Array.isArray(data) || data.length === 0) {
        throw new Error('Data must be a non-empty array.');
    }
}

Наша функция validateNonEmpty проверяет,  что входные данные являются непустым массивом. Функция выполняет свою задачу,  однако очевидно,  что она добавляет нам надежности только в месте использования.  Далее в коде может возникнуть большое количество случаев, где нам раз за разом придется выполнять одну и ту же проверку.  Интуитивно понятно,  что это далеко не самый оптимальный подход.

Парсинг

Если говорить об общем определении,  то я бы сказал, что парсер - это функция, которая структурирует данные.

Цель парсинга -  проверить данные на соответствие определенным критериям, провести преобразования в случае соответствия и вернуть структурированные данные.

На первый взгляд, цель перекликается с валидацией, но мы видим важное отличие: это структурирование данных и возврат значения.

Чтобы наглядно продемонстрировать, как Zod парсит значние,  можно рассмотреть пример:

задаем базовую схему

задаем значение для проверки

видим, что на выходе мы получили только значение,   которое соответствует заданной структуре схемы



Zod придерживается подхода parse, don’t validate, описанного в одноименной статье Parse, don't validate by Alex King.  Парсинг хорош тем, что получаемые на выходе данные хранят в себе всю информацию, которую мы узнали в ходе проверок и преобразований. Каждый раз, получая выходное значение, мы сужаем его тип.  Это дает нам уверенность в том, с какой структурой мы работаем в любом месте кода, и позволяет не проверять одни и те же кейсы  несколько раз,  в отличие от того, что было продемонстрировано в случае подхода с валидацией данных.

Схема в Zod выстроена по принципу матрешки: на начальных этапах всегда проверяются кейсы,  которые могут в моменте дать нам больше всего полезной информации и отсечь максимальное количество проверок. Далее уже происходит движение в сторону менее информативных проверок, что и заложено в основу подхода Parse, don't validate.

Схема всегда начинается с описания типа, например: z.string(), z.number() и т.д ,  чтобы уже на следующем шаге мы могли использовать преднастроенный набор готовых проверок, например: z.string().min(5),  или же писать свои собственные,  основываясь на полученной информации после проверки типа:

z.string().refine((val) => val.length <= 255, {
        message: "String can't be more than 255 characters",
      })

В качестве прочих важных моментов, характеризующих подход parse, don’t validate, я бы выделил следующее:

-успешный парсинг является показателем валидности данных (валидацию можно рассматривать как следствие парсинга)

-входные данные имутабельны, результатом парсинга всегда является deepClone

-для парсинга используются чистые функции, что повышает устойчивость и предсказуемость результата

-Let your datatypes inform your code, don’t let your code control your datatypes. Отдавайте приоритет качественному проектированию модели и использованию подходящих структур данных с целью точного отражения семантики. Не подгоняйте модель под ваш код лишь для того,  чтобы меньше думать и делать меньше рефакторинга. Чем более подходящие структуры данных вы используете, тем меньше проверок вам понадобится, и тем надежнее и понятнее будет ваш код. Не бойтесь рефакторинга.

Принципиальные отличия zod от yup

yup - это валидатор, а zod - парсер. О различиях между парсером и валидатором можно прочитать выше в главе общая информация. Область применения zod на самом деле может быть гораздо шире, чем простая валидация данных.

в yup используется метод .validateSync(),  в zod  .parse()

в yup используется метод .test() для кастомной валидации, в zod используется .refine(), .superRefine() и .custom()

все поля в zod по умолчанию required, а в yup они optional

yup.object().shape() позволяет определить структуру объекта, например  yup.object().shape({name: yup.string()}),  в zod структура объекта определяется исключительно внутри метода .object(), например z.object({name: z.string()}). В zod также присутствует метод .shape(), однако он используется, чтобы извлечь схему для конкретного ключа объекта, например:

const Dog = z.object({ name: z.string(), age: z.number()});

Dog.shape.name; // => string schema
Dog.shape.age; // => number schema

в отличии от yup,  где поддержка TS была добавлена относительно недавно, zod изначально разрабатывался с использованием подхода TypeScript-first (Zod was designed to mirror TypeScript as closely as possible), в результате чего api  здесь интуитивно гораздо более очевидное и понятное тем, кто имеет опыт работы с TS

Правила построения  моделей и схем

Пункты далее расположены в произвольном порядке (не в порядке важности):

Не завязывайтесь на структуры данных,  которые вы получаете напрямую с бэкэнда.

На мой взгляд, это можно вообще назвать антипаттерном по следующим причинам:

Неудобный формат.Бэкэнд предоставляет модели, оптимизированные для работы с БД, которые удобны для их внутренней обработки. Нам же зачастую этот формат не подходит. Прямое отражение таких данных в интерфейсе приводит к громоздкому коду и необходимости частых дополнительных промежуточных преобразований при работе

Сильная зависимость от действий разработчиков бэкэнда.Если использовать модели бэка, то мы сильно завязываемся на их код,  и даже при небольших изменениях с их стороны, могут потребоваться значительные изменения с нашей

Усложнение схемы валидации.Чем сложнее модель - тем сложнее валидация. Бэк при написании модели не руководствуется тем, что на самом деле удобно для нас

Рекомендация: создавайте промежуточную модель(view model), которая упрощена и оптимизирована для удобной работы и отображения в интерфейсе. Выделяйте маппинг-слой для преобразования данных:  back-end model => view model; view model => back-end model.

Получайте модель для формы из схемы там, где это возможно.

Единственный источник правды.Изменяя схему вы изменяете модель, используемую формой. Данный подход крайне надежен с точки зрения Typescript,  так как обмануть TS и использовать различные костыли уже не получится.

Предсказуемая структура.Уже на этапе получения макета от дизайнера, вы имеете представление о типах данных в конкретных филдах, а также о том, какие доп. кейсы должна покрывать ваша валидация. Сформировав схему до начала написания формы вы получите четкое понимание того,  на какие секции может быть разделена ваша форма,  а также заранее подумаете об edge кейсах. Все это неизбежно приведет к более чистому коду с меньшим количеством непонятных и непродуманных решений.

Уменьшение дублирования типов.Часто типы Typescript путешествуют по папкам непонятным образом, что приводит к их непреднамеренному дублированию. Также у разработчиков часто существует свое видение того, куда эти типы нужно складывать. Формирование модели по схеме решает эти проблемы.

Корректная типизацияУровень владения Typescript у разработчиков разный.  Не все понимают, какие типы являются предпочтительными в той или иной ситуации,  а о каких-то конструкциях могут просто не знать. Библиотека Zod имеет большое количество преднастроенных утилит,  которые позволяют нивелировать эту разницу в опыте/навыках работы  с Typescript. Zod утилиты покрывают абсолютное большинство нативных типов и конструкций Typescript,  в том числе и достаточно сложные, например Discriminated unions. Получается,  что библиотека сама корректно формирует тип на основе схемы, вместо того,  чтобы разработчик делал это вручную.

Не пишите громоздкие схемы

Сложно воспринимать информацию.Большое вол-во кода в одном месте значительно ухудшает читаемость.

Сложно редактировать.Коррелирует с первым пунктом, редактирую громоздкий код всегда легче допустить ошибку.

Отсутствие гибкости.Часто в формах присутствует деление компонентов по секциям. Данные секции могут использоваться в разных формах, следовательно общая схема ну уровне формы в данном случае будет крайне нудобна.

Рекомендация: Делите схемы на секции,  аналогично делению формы и храните их рядом на одном уровне (т.е секция должна экспортировать  cхему). Это избавляет нас от перечисленных выше проблем, добавляет нам предсказуемости и гибкости, а также дает возможность переиспользовать компоненты.  Далее на уровне формы вы можете уже собрать общую схему формы из секций.

Обработка ошибок

ErrorMap

Ошибки Zod можно кастомизировать. Для этого необходимо создать функцию, которая генерирует custom error message.

import {z} from 'zod';

const customErrorMap: z.ZodErrorMap = (issue, ctx) => {
    if (issue.code === z.ZodIssueCode.invalid_type) {
        if (issue.expected === 'string') {
            return {message: 'bad type!'};
        }
    }
    if (issue.code === z.ZodIssueCode.custom) {
        return {message: `less-than-${(issue.params || {}).minimum}`};
    }
    return {message: ctx.defaultError};
};

Подробнее про ZodIssue и ZodIssueCode: https://zod.dev/ERROR_HANDLING?id=zodissue | https://zod.dev/ERROR_HANDLING?id=zodissuecode

Обрабатывать все возможные ZodIssueCode необязательно,  для непокрытых кейсов будет применяться стандартная обработка с базовыми кейсетами zod.

Ошибки можно переопределить для конкретного файла с помощью z.setErrorMap(customErrorMap),  или для конкретной схемы (подробнее об этом далее).

Полезные ссылки

Наша глобальная кастомизации ошибок: cloud-console custom error map

Как  получить каждую конкретную ошибку в нашей customErrorMap: errors explanation

Раздел в официальной документации https://zod.dev/ERROR_HANDLING?id=customizing-errors-with-zoderrormap

Playground zod, чтобы можно было наглядно все опробовать:  https://zod-playground.vercel.app/

Кастомизация ошибок в базовых схемах

Для переопределения в схеме "по месту" можно воспользоваться одним из трех вариантов (их нельзя миксовать,  иначе получим ошибку). Рассмотрим на примере схемы для строки (для всех схем подход аналогичен):

можно передать полноценную error map



можно отдельно передать значение для  кейса undefined и для кейса invalid_type (возникает если передать например number в схему для string)



можно просто передать custom error message (будет использован для обоих кейсов выше)



Кастомизация ошибок для метода refine

Полезная информация

Метод .refine() является своего рода аналогом метода .test() в yup.

Он предназначен для написания кастомных (уточняющих) проверок, которые нельзя выразить определенным типом TS, например:

z.string().refine((val) => val.length <= 255, { message: "String can't be more than 255 characters"})

Вы можете использовать его, когда встроенные методы Zod не удовлетворяют вашим требованиям к валидации.

Возвращаемое значение функции валидатора должно быть true/false.

Ошибки на выходе всегда имеют ZodIssueCode.custom.

Первым аргументом метод принимает функцию валидации, которая должна возвращать true или false

Вторым аргументом  метод принимает набор опций для кастомизации ошибки



Если нам необходимо использовать входное значение, то вместо набора опций вторым аргументом можно передать функцию, которая будет возвращать этот набор опций

z.string().refine(
    (val) => val.length > 10,
    (val) => ({message: `${val} is not more than 10 characters`}),
);

или например если мы используем customErrorMap, то можно передать value в params(их в свою очередь можно использовать внутри customErrorMap)

z.string().refine(
    (val) => val.length > 10,
    (val) => ({params: val}),
);

Наглядный пример кастомизации ошибки refine из документации:



Кастомизация ошибок для метода superRefine

Полезная информация

Метод .refine() является синтаксическим сахаром для метода .superRefine()

superRefine поставляется с дополнительным вторым аргументом 'context'. Для установки ошибки необходимо вызвать метод context.addIssue.

Данный метод в отличии от refine позволяет сгенерировать произвольное количество ошибок, а также дает возможность управлять ZodIssueCode.

Функция валидации не должна возвращать никаких значений. Критерием успешности валидации является тот факт, был ли хотя бы раз вызван context.addIssue.



Методы,  часто вызывающие сложности

Lazy

Данный метод позволяет создавать 'отложенные' схемы - то есть схемы,  структура которых окончательно формируется в рантайме,  непосредственно в процессе парсинга.

Важно

Тот факт, что структура подобных схем определяется в рантайме не означает,  что z.lazy () стоит использовать для Conditional Schema Definition, подробнее читайте в параграфе "Использование  yup.lazy() не по назначению".

Используйте z.lazy() исключительно для формирования рекурсивных схем!

Рассмотрим наглядный пример из официальной документации:



Изначально мы не знаем, какой вложенности будут наши итоговые данные, что крайне затрудняет формирование статической схемы. Именно здесь нам идеально подойдет z.lazy(). Формируя рекурсивную структуру, мы создаем циклическую ссылку, TS не умеет такое инферить,  поэтому мы должны для такого случая сформировать тип 'ручками' и передать его в zod в качестве "type hint" :  const categorySchema: z.ZodType<Category> = …

Coerce

Данный метод используется для преобразования примитивов.



Важно

zod - это парсер, при использовании .coerce() значение на выходе из метода .parse() будет преобразовано в указанный тип. Подробнее https://zod.dev/?id=coercion-for-primitives

Transform

Данный метод,  аналогично методу .coerce() используется для трансформации выходных значений, однако, он значительно добавляет гибкости, так как производит не только примитивные преобразования. Подробнее https://zod.dev/?id=transform



Preprocess

Данный метод, похож на метод .transform(), но используется для трансформации входных значений. Подробнее https://zod.dev/?id=transform



Pipe

Данный метод позволяет создавать validation pipelines c использованием трансформаций. Говоря простым языком. без метода .pipe вы не сможете продолжить валидацию трансформированного значения. Подробнее https://zod.dev/?id=pipe



Literals

Используйте, когда нужен более узкий тип. Подробнее https://zod.dev/?id=pipe



получим типы:

type Tuna = "tuna"
type Twelve = 12
type TwoBig = 2n
type Tru = true

Refine

Подробнее #kastomizaciya-oshibok-dlya-metoda-refine

SuperRefine

Подробнее #kastomizaciya-oshibok-dlya-metoda-superrefine

Частые ошибки

В данном разделе рассмотрим примеры некорректного использования yup в коде Cloud Console.  Все ситуации также актуальны и для  zod.

Попытка получить доступ к значению всей формы изнутри какого-либо поля схемы:

Так делать не нужно

function getContextAllValues(ctx: yup.TestContext): FormValues | undefined {
    // @ts-expect-error
    return ctx.options.from?.[ctx.options.from?.length - 1]?.value;
}

const documentSecondaryIndexesSchema = yup.array().test('shard-or-sort', i18nK('label_error-indexes-key'), function (this, indexes) {
                if (!indexes) {
                    return true;
                }

                const allValues = getContextAllValues(this);
                const columns = new Set(allValues?.documentColumns.map(({name}) => name));

                return (indexes as DocumentSecondaryIndex[]).every(
                    ({shardColumn, sortColumn}) =>
                        shardColumn &&
                        columns.has(shardColumn) &&
                        (!sortColumn || columns.has(sortColumn)),
                );
            })

Почему подобный подход ошибочен

ctx.options.from намеренно никак не описан в официальной документации, по факту это хак, который приводит к неприятным последствиям:

во-первых, это снижает общую надежность нашей схемы, так как у нас нет никакой гарантии работоспособности подобного подхода

во-вторых,  инструмент используется не так, как это задумывалось автором библиотеки. В данном случае мы вынуждены обманывать TS и ломать тайпинги + это приводит к ухудшению читаемости, потому что, следуя документации, подобный кусочек кода с методом .test() ожидается в другом месте,  а именно на самом верхнем уровне в схеме формы

Как делать правильно (рассмотрим сразу на примере +- схожей схемы zod)



Что изменилось:

refine выносится на самый верхний уровень (то же самое можно было проделать с методом .test() в yup)

внутри refine мы спокойно выполняем проверку и задаем path для установки ошибки

Использование  yup.when() для динамического формирования схемы

Так делать не нужно

export function getLoggingSectionValidationSchema(): ObjectSchema {
    return object().shape({
        loggingEnabled: boolean().required(),
        loggingDestination: string().when('loggingEnabled', {
            is: true,
            then: string().required().oneOf(Object.values(LoggingDestination)),
        }),
        loggingFolderId: string().when('loggingDestination', {
            is: LoggingDestination.Folder,
            then: string().required(),
        }),
        loggingGroupId: string().when('loggingDestination', {
            is: LoggingDestination.LogGroup,
            then: string().required(),
        }),
        loggingStreams: object().when('loggingEnabled', {
            is: true,
            then: object({
                [LoggingStream.Audit]: boolean().required(),
                [LoggingStream.ClusterAutoscaler]: boolean().required(),
                [LoggingStream.Events]: boolean().required(),
                [LoggingStream.KubeApiserver]: boolean().required(),
            }).required(),
        }),
    });
}

Почему подобный подход ошибочен

Чтобы понять проблему, разложим на 2 части, написанное выше (рассмотрим  например поле loggingStreams):

loggingStreams: object()

object().when('loggingEnabled', {
            is: true,
            then: object({
                [LoggingStream.Audit]: boolean().required(),
                [LoggingStream.ClusterAutoscaler]: boolean().required(),
                [LoggingStream.Events]: boolean().required(),
                [LoggingStream.KubeApiserver]: boolean().required(),
            }).required(),
        })

На самом деле,  с точки зрения TS, мы окончательно определили модель в пункте 1 (TS и yup теперь считают, что в loggingStreams у нас должно лежать {} | undefined), все что происходит в пункте 2 внутри when для TS не имеет абсолютно никакого значения, так как type  inference не работает в методе when. Для наглядности посмотрим на реализацию метода .when() в yup (приведу лишь одну из overload signatures,  которая соответствует конкретно рассматриваемому кейсу):

when(keys: string | string[], builder: ConditionBuilder<this>): this;

type ConditionConfig<T extends ISchema<any>> = {
  is: any | ((...values: any[]) => boolean);
  then?: (schema: T) => ISchema<any>;
  otherwise?: (schema: T) => ISchema<any>;
};

Кажется,  что без доп. объяснений понятно,  что о нормальной типизации и type inference здесь речи не идет.

Если подумать, то в данном примере мы пытаемся сгенерировать схему налету,  но это в корне не правильно (мы ведь не генерируем модели динамически,  верно? 🙃).  Метод .when() в yup хорошо подходит разве что для уточняющих проверок, которые не меняют исходный тип,  например number().min(10).

На основе рассмотренного выше можно сделать вывод:

Api библиотеки yup не позволяет реализовать такие вещи,  как структуры, как oneOf и discriminated union.

Несмотря на все улучшения,  которые были проделаны в последнем мажоре yup по части TS,  мы все равно не можем получить нормальный infer и работать без костылей.

Как делать правильно

Zod в отличии от yup построен с использованием подхода TS-first и позволяет сформировать перечисленные выше структуры без особых проблем нативными методами: z.union, z.discriminatedUnion. В zod  отсутствует аналог метода .when(), вот что пишет о причинах автор библиотеки:

Feature: Conditional Validation Similar to yup.when() #1394: https://github.com/colinhacks/zod/issues/1394

This isn't going to happen in Zod, sorry folks. I find the .when API very unaesthetic and it adds nothing in terms of type safety. There's no other scenario where Zod has you specify object keys with strings; it's hacky and looks bad. It breaks locality. The reason Zod is easy to learn is because it's clean and compositional. There's no reason a child schema in a ZodObject should behave differently based on its sibling fields, ever.

Использование  yup.lazy() не по назначению

Так делать не нужно

const targetGroupNameValidator = fieldValidateFactory(
    lazy((value) => (value === '' ? string() : defaultAlbEntityNameSchema)),
);

Почему подобный подход ошибочен

Собственно говоря,  причина здесь такая же, как и в параграфе выше, где рассматривался метод yup.when():  нельзя менять схему 'на лету'. Conditional schemas - это антипаттерн!

Как делать правильно

Базовая рекомендация - потратить чуть больше времени на продумывание структуры схемы,  подобные вещи решаются использованием стандартных типов zod, таких как, например, union. Если нам по какой-то причине необходимо прогнать дополнительные опциональные проверки,  то нужно для этих целей использовать методы .refine() или .superRefine()
